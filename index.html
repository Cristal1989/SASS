<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Препроцессоры</title>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />
    <link rel="stylesheet" href="./style/style.css" />
  </head>

  <body class="body">
    <header class="header">
      <div class="container">
        <h2 class="title">sass</h2>

        <ul>
          <b>Приимущества</b>
          <li>
            Совместимость - синтаксис препроцессора полностью совместим с уже
            существующими css правилами. Готовый css код можно вставить в sass
            файл, но не наоборот
          </li>
          <li>
            Богатый функционал - большое кол-во спомогательных конструкций для
            упрощения основных задач при написании css кода
          </li>
          <li>
            Стректура проэкта - препроцессор позволяет писать стили в отдельных
            файлах, что повышает качество структуры проэкта и поиска стилей
            отдельных блоков
          </li>
          <li>
            Чистота кода - из за того, что стили пишутся в отдельных файлах и
            применяются вспомогательные конструкции для повторного использования
            кода, он становится чище
          </li>
          <br />
          <br />
          <b>Недостатки</b>
          <br />
          <li>
            Синтаксис - дополнительная конструкция препроцессора это новый
            синтаксис, который необходимо выучить и привыкнуть использовать
          </li>
          <li>
            Компиляция - шаг подготовки препроцессора для браузера, т.е
            преобразование всех синтаксических конструкций в обычный css.
          </li>
        </ul>
        <h2 class="title">Синтаксис</h2>
        <p>
          В начале препроцессор SASS имел одноименный синтаксис - sass. Для
          описания вложенностей он использует отступы вместо фигурных скобок,
          что понижает читабельность и повышает вероятность сделать ошибку. Файл
          с этим синтаксисом имеет расширение <b>.sass</b>, например main.sass
        </p>
        <p class="bg">
          main.sass <br />
          /* ❌ Старый синтаксис SASS */ <br />
          .box <br />
          width: 400px; <br />
          height: 400px; <br />
          background-color: teal; <br /><br />

          &amp;:hover <br />
          background-color: orange;
        </p>
        <p>
          Cегодня используется синтаксис scss(Sassy CSS), который является
          расширением оригинального css синтаксиса. Это значит, что любые
          доступные значения в css стилях будут доступны в scss. Файлы с жтим
          синтаксисом имеют расширение <b>.scss</b>, например main.scss.
        </p>
        <p class="bg">
          main.scss <br />
          /* ✅ Новый синтаксис SCSS */ <br />
          .box { <br />
          width: 400px; <br />
          height: 400px; <br />
          background-color: teal; <br /><br />

          &amp;:hover {<br />
          background-color: orange;<br />
          } <br />
          }
        </p>
        <h2 class="title">Компиляция</h2>
        <p>
          Браузер не понимает синтаксис специальных конструкций sass, поэтому
          код препроцессора необходимо преобразовать(скомпилировать) в css.
        </p>
        <p>Процесс разработки сводится к след шагам</p>
        <ul>
          <li>Настраиваем инструмент для компиляции SASS кода</li>
          <li>Пишем код в файлах с расширением .scss</li>
          <li>SASS автоматически компилирется в css и создается в css файле</li>
          <li>Подключаем скомпилированый css файл в index.html</li>
        </ul>
        <p><b> &:hover</b> - амперсант(&) который определяет вложенность</p>
        <p><b> $var</b> - обхявление переменной</p>
        <p class="bg">
          .box{ <br />
          width: 100px; <br /><br />

          &:hover { <br />
          background: #fff; <br />
          } <br />
          }
        </p>
        <h2 class="title">Переменные</h2>
        <p>
          Переменные и операции над ними - это одна из простых и в то же время
          самых мощных особенностей препроцессора. Синтаксис объявления
          переменной - $, перед именем ее значения после двоиточия.
        </p>
        <p class="bg">
          main.scss <br />
          $primaryColor: #888; <br />
          $cardBorderRadius: 4px; <br /><br />

          .product { <br />
          background-color: $primaryColor; <br />
          border-radius: $cardBorderRadius; <br />
          }
        </p>
        <p>
          Имена переменных должны быть логичными, чтобы по имени было понятно
          что там хранится $colorBlue, можно добавить смысла еще больше
          $colorAccent $colorTheme $colorBg
        </p>
        <h2 class="title">Область видимости</h2>
        <p>
          Переменные доступны только в пределах того уровня вложенности
          селектора, на котором они определены, т.е если переменная объявлена в
          селекторе, она доступна только в нем. Переменная, объявленная в не
          каких либо селекторов доступна глобально.
        </p>
        <h2 class="title">Вложенные правила</h2>
        <p>
          Подобно вложенностям тегов в HTML в SASS можно вкладывать css
          селекторы - это одна из наиболее полезных, а так же используемых
          возможностей. Вложенность позволяет делать одни объявления правил
          внутри других. Синтаксис scss выглядит более чистым и менее
          повторяющимся. После компиляции в стандартный css файл мы получаем код
          как в main.css но в процессе разработки писать код будет удобнее.
        </p>
        <h2 class="title">Конкатинация селектора</h2>
        <p>
          Символ амперсант <b>"&"</b> позволяет указать в какое место необходимо
          поставить родительский селектор.
        </p>
        <h2 class="title">Правила вложенности</h2>
        <p>
          Вложеность селекторов это отличный способ сэкономить время и упростить
          поддержку кода. Но черезмерная вложенность гарантировано вызовет
          проблемы с читабельностью кода
        </p>
        <h2 class="title">Арифметические операции</h2>
        <p>
          До того как в css появилась функция calc() препроцессоры были
          единственным решением при необходимости вычеслить арифметические
          вычесления
        </p>
        <h2>Сложение и вычетание</h2>
        <p>
          В отличие от функции calc() в препроцессоре нельзя смешивать типы
          едениц. При попытке выполнить сложение или вычетание совместимых типов
          будет ошибка.
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          .box { <br />
          width: 960px + 10%; // Ошибка! <br />
          width: 960px + 30px; // 990px <br />
          width: 960px + 30; // 990px <br />
          width: 100% + 20%; // 120% <br /><br />

          width: 100% - 50px; // Ошибка! <br />
          width: 960px - 30px; // 930px <br />
          width: 960px - 30; // 930px <br />
          width: 100% - 20%; // 80% <br />
          }
        </p>
        <p>
          Дело в том что препроцессоры не знают сколько будет 100% или 5em в
          пикселях заранее. Значение относительных едениц можно узнать только в
          момент рендера HTML документа. Поэтому для вычесления необходимо
          использовать нативную функцию calc()
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          .box { <br />
          width: calc(100% - 20px); <br />
          width: calc(5em + 20px); <br />
          }
        </p>
        <h2>Умножение</h2>
        <p>
          Выполняется аналогично функции calc() в css, за исключением того, что
          нельзя умножить несовместимые типы.
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          $value: 50px; <br /><br />

          .box {<br />
          // 1 - значение хранится в переменной. <br />
          width: $value / 5; // 10 <br /><br />

          // 2 - значения заключены в круглые скобки.<br />
          width: (100px / 5); // 20px<br /><br />

          // 3 - значение используется как часть другого выражения.<br />
          width: 100px / 5px + 10px; // 30px<br />
          }
        </p>
        <h2>Деление</h2>
        <p>
          Деление в препроцессорах выполняется в трех случаях - когда значение
          хранится в переменной, когда значение заключено в круглые скобки и
          когда значение используется как часть другого выражения.
        </p>
        <p class="bg">
          <b>main.css</b> <br />
          $value: 50px; <br /><br />

          .box {<br />
          // 1 - значение хранится в переменной.<br />
          width: $value / 5; // 10<br /><br />

          // 2 - значения заключены в круглые скобки.<br />
          width: (100px / 5); // 20px<br />

          // 3 - значение используется как часть другого выражения.<br />
          width: 100px / 5px + 10px; // 30px<br />
          }
        </p>
        <h2 class="title">Переменные в операциях</h2>
        <p>
          Если в арифметических операциях используются валидные значения
          переменной, то не будет никаких проблем
        </p>
        <p class="bg">
          <b>main.scss</b> <br /><br />
          $gridItemMargin: 20px; <br /><br />

          .box {<br />
          margin: $gridItemMargin * 2;<br />
          }
        </p>

        <p>
          В таких случаях необходимо делать интерполяцию, значение переменной
          используется в спец конструкции #{$имя_переменной}
        </p>
        <p class="bg">
          <b>main.scss</b> <br /><br />

          $gridMargin: 20px; <br />
          .box { <br />
          margin: calc(#{$gridMargin} / 2) }
        </p>
        <h2 class="title">Директива @import</h2>
        <p>
          Писать весь код в одном фале не удобно, поэтому препроцессор SASS
          позволяет хранить стили в отдельных файлах и собирать их как мозайку,
          такой модульный подход к написанию кода упрощает рефакторинг и
          поддержу кодовой базы <br /><br />
          По умолчанию SASS компилятор создает css файл для каждого SASS файла,
          который встретит в проэкте. Для того чтобы компиляция получила 1 файл
          стилей испорльзуются фрагменты (partials) обычные SASS файлы, имя
          которых начинается с нижнего подчеркивания _logo.scss. Нижнее
          подчеркивание говорит компилятору о том, что это фрагмент и он должен
          компилироваться в отдельном css файле.
        </p>
        <img
          src="./images/project-structure.jpg"
          alt=""
          class="img"
          width="600"
        />
        <p>
          На иллюстрации изображена базовая структура SASS файлов. В папке SASS
          есть один главный файл main.scss, для которого после компиляции будет
          создан файл min.css, который мы подключаем к index.html. В папке utils
          и components лежат фрагменты, которые будут частью main.scss <br />
          <br />
          Для того чтобы подключить фрагменты в другой css файл используется
          директива @import. Файл main.scss будет выглядеть следующим образом
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          @import 'utils/colors'; <br />
          @import 'utils/mixins'; <br />
          @import 'components/header'; <br />
          @import 'components/logo'; <br />
          @import 'components/site-nav'; <br />
          @import 'components/section';
        </p>
        <p>
          Когда компилятор встречает директиву @import он подставляет код
          импортируемого файла вместо импорта. После компиляции получается один
          css файл, компилируемый из нескольких фрагментов
        </p>
        <h2 class="title">Директива @extend</h2>
        <p>
          Директива @extend используется для наследования (расширения) уже
          существующих стилей.
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          .button { <br />
          display: inline-flex; <br />
          border-radius: 3px; <br /><br />
          font-size: 16px;<br />
          padding: 10px 20px;<br />
          color: white;<br />
          background-color: gray;<br />
          }<br /><br />

          .button-success {<br />
          @extend .button;<br />
          background-color: green;<br />
          }<br /><br />

          .button-error {<br />
          @extend .button;<br />
          background-color: red;<br />
          }
        </p>
        <p>
          Расширение (наследование) не сделает копию стилей для каждого
          селектора, а грамотно добавит нужные селекторы перечесление к правилу
          с наследуемыми стилями
        </p>
        <h2>Шаблоны плейсхолдеры</h2>
        <p>
          Но что если мы хотим расширить набор стилей базовый селектор для
          которого не нужен? Например если не нужен селектор .button, ведь сам
          по себе использоваться не будет. Для таких случаев существует
          <b>placeholder</b> (плейсхолдер, местозаполнитель, шаблон) -
          произвольное имя селектора с обязательным символом % в начале.
        </p>
        <p class="bg">
          <b>main.scss</b> <br /><br />
          %button { <br />
          свойства <br />
          } <br /><br />

          .button-success { <br />
          @extend %button; <br />
          background-color: green; <br />
          } <br />
          <br />

          .button-error { <br />
          @extend %button; <br />
          background-color: red;<br />
          }
        </p>
        <p>
          После компиляции будут доступны селекторы .button-success
          .button-error привязаные к правилу шаблона, а самого имени шаблона в
          css не будет
        </p>
        <h2 class="title">Директива mixin</h2>
        <p>
          Миксины или примеси как и плейсхолдеры позволяют создавать готовые
          наборы свйоств, но с различным значением в зависимости от полученых
          аргументов при вызове миксина
        </p>
        <p class="bg">
          @mixin имя(параметры){ <br />
          свойство <br />
          }
        </p>
        <p>
          Миксин объявляется с помощью директивы @mixin и его имени. Далее могут
          идти не обязательные параметры в круглых скобках (сами скобки
          обязательны) а в фигурных набор свойств и значений
        </p>
        <p class="bg">
          @mixin boredRed($colorRed){ <br />
          border-top: 1px solid $colorRed; <br />
          border-bottom: 1px solid $colorRed; <br />
          }
        </p>
        <p>
          Добавить стили миксина к селектору можно с помощью директивы @include,
          после которой вызывается миксин и передается значения для
          настраиваемых свойств
        </p>
        <p class="bg">
          @mixin borderRed($colorRed){ <br />
          border-top: 1px solid $colorRed; <br />
          border-bottom: 1px solid $colorRed; <br />
          } <br />
          .section { <br />
          @include borderRed(tomato); <br />
          padding: 10px; <br />
          } <br />
          .header { <br />
          @include borderRed(teal); <br />
          min-height: 360px; <br />
          } <br />
        </p>
        <p class="information">
          Миксины отличаются от плейсхолдера тем, что свойства дублируются в
          каждый селектор. Все потому что значения свойств миксина могут быть
          разные в зависимости от переданых аргументов при вызове @include
          mixin_name(аргументы), в то время как свойства и значения в
          плейсхолдере всегда одинаковые.
        </p>
        <h2 class="title">Директива @each</h2>
        <p>
          Директива @each - это цикл который выполнит тело директивы для каждого
          значения из списка - это позволяет сократить количество кода, который
          необходимо написать вручную.
        </p>
        <p class="bg">
          @each &lt;значение&gt; in &lt;список значений&gt; { <br />
          тело <br />
          }
        </p>
        <p>
          Например необходимо создать серию селекторов для элементов фоновыми
          изображениями. В css это выглядит следующим образом - слишком много
          повторяющегося кода.
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          .dog-icon { <br />
          background-image: url('../images/dog.png'); <br />
          }<br /><br />

          .cat-icon {<br />
          background-image: url('../images/cat.png');<br />
          }<br /><br />

          .bird-icon {<br />
          background-image: url('../images/bird.png');<br />
          }<br /><br />

          .turtle-icon {<br />
          background-image: url('../images/turtle.png');<br />
          }
        </p>
        <p>
          Используя @each можем добиться того же результата записав следующий
          SASS код, который будет скомпилирован в css
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          <br />
          $animal:icon.svg <br />

          @each $animal in dog, cat, bird, turtle { <br />
          .#{$animal}-icon{background-image: url("../images/#{animal}.png")
          <br />
          } <br />
          }
        </p>
        <p>
          Директива @each устанавливает $animal каждой из значений списка и для
          каждого создает код в теле директивы - css правило с селектором класса
          и набором свойств
        </p>
        <h2>Карты словари</h2>
        <p>
          Объявляем несколько переменных для хранения палитры цветов полей, по
          сути это набор переменных с префиксом color для указания того, что они
          хранят
        </p>
        <p class="bg">
          <b>_colors.scss</b> <br />
          <br />
          $color-primary: #8e3329; <br />
          $color-accent: #d98328; <br />
          $color-secondary: #5a1321; <br />
          $color-foreground: #191919; <br />
          $color-background: #e9e9e9;
        </p>

        <p>
          Карта словарь позволяет хранить набор связаной информации в формате
          <b>термин:определение</b>. Например вместо нескольких не связаных
          переменных, хранящих палитру можно записать карту цветов. Карта
          состоит из имени переменной, в которой она хранится и набора свойств в
          формате <b>ключ:значение</b> разделенных запятыми, внутри пары круглых
          скобок
        </p>
        <p class="bg">
          <b>_colors.scss</b> <br />
          <br />
          $colors: ( <br />
          "primary": #8e3329; <br />
          "accent": #8e3329; <br />
          "secondary": #8e3329; <br />
          "foreground": #8e3329; <br />
          "background": #8e3329; <br />
          )
        </p>
        <p>
          Имя цвета может быть произвольным, это просто название свойства. Такая
          карта позволит упорядочено и многократно получать доступ к цветам. Для
          того чтобы получить значение свйоства используется встроенная SASS
          функция <b>map-get()</b>
        </p>
        <p class="bg">map-get(имя_функции, имя_свойства)</p>
        <p>
          Первым аргументом передаем имя переменной, в которой находится
          словарь, вторым свойство значения которое необходимо получить. Имя
          свойства должно быть строкой, т.е обернутое в двойные или одинарные
          ковычки
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          <br />
          @import "./colors" <br />
          body { <br />
          background-color: map-get($colors, "background"); <br />
          }
        </p>
        <p>
          Постоянно писать map-get() и передавать имя карты не удобно. Напишем
          функцию-утилиту для более простого доступа к свойствам карты цветов.
          Эту функцию объявим в том же файле где и карта
        </p>
        <p class="bg">
          <b>_colors.scss</b> <br />
          <br />
          $colors: ( <br />
          "primary": #8e3329; <br />
          "accent": #8e3329; <br />
          "secondary": #8e3329; <br />
          "foreground": #8e3329; <br />
          "background": #8e3329; <br />
          ) <br />
          @function getColor($key) { <br />
          @return map-get($colors, $key) <br />
          }
        </p>
        <p>
          После импорта файл _colors.scss можно использовать функцию
          getColor(имя_свойства)
        </p>
        <p class="bg">
          <b>main.scss</b> <br />
          <br />
          @import "./colors" <br />
          .button { <br />
          color: getColor("primary"); <br />
          background-color: getColor("accent"); <br />
          }
        </p>
        <h2 class="title">Вендорные префиксы</h2>
        <p>
          Вендорные префиксы это специальные приставки используемые
          производителями (вендорами) браузеров для эксперементальных, еще не
          принятых стандартов или не полностью реализованых в браузере css
          свойств и значений <br />
          Список вендорных префиксов по браузерам
        </p>
        <ul>
          <li><b>-webkit-</b> - хром, сафари, edge, новая версия оперы</li>
          <li><b>-moz-</b> - это firefox</li>
          <li><b>-o-</b> - это старая версия оперы</li>
          <li><b>-ms-</b> - internet explorer</li>
        </ul>
        <p class="information">
          Вручную прописывать их не нужно, для этого используются спец
          инструменты, котрые автоматизируют процесс, например SASS компилятор с
          доп настройками.
        </p>
        <p>
          Например следующий css код будет работать в большинстве последних
          версий современных браузеров
        </p>
        <p class="bg">
          .example { <br />
          display: flex; <br />
          transition: all 0.5s; <br />
          background: linear-gradient(to bottom, white, black);<br />
          }
        </p>
        <p>
          После обработки автопрефиксером получаем следующий код, который будет
          гарантировано работать в последних четырех версиях современных
          браузеров. Браузеры которые поддерживают нативные свойства и значения
          проигнорируют их аналоги с вендорным префиксом и наоборот
        </p>
        <p class="bg">
          .example { <br />
          display: -webkit-box; <br />
          display: -ms-flexbox; <br />
          display: flex; <br /><br />

          -webkit-transition: all 0.5s; <br />
          -o-transition: all 0.5s; <br />
          transition: all 0.5s; <br /><br />

          background: -webkit-gradient(<br />
          linear,<br />
          left top,<br />
          left bottom,<br />
          from(white),<br />
          to(black)<br />
          );<br />
          background: -o-linear-gradient(top, white, black);<br />
          background: linear-gradient(to bottom, white, black);<br />
          }
        </p>
      </div>
    </header>
    <script src="./js/script.js"></script>
  </body>
</html>
